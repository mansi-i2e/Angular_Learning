{
  "version": 3,
  "sources": ["../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/normalizeOptions.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/pdf_utils.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/row_utils.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/height_updater.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/rows_generator.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/draw_utils.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/rows_spliting_utils/get_multipage_row_pages.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/rows_spliting_utils/create_on_split_multipage_row.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/rows_splitting.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/common/export.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/export_data_grid.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/autotable/export.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/autotable/export_data_grid.js", "../../../../../../node_modules/devextreme/esm/exporter/jspdf/export_gantt.js"],
  "sourcesContent": ["/**\r\n * DevExtreme (esm/exporter/jspdf/common/normalizeOptions.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isNumeric } from \"../../../core/utils/type\";\nfunction normalizeBoundaryValue(value) {\n  if (isNumeric(value)) {\n    return {\n      top: value,\n      right: value,\n      bottom: value,\n      left: value\n    };\n  }\n  return {\n    top: (null === value || void 0 === value ? void 0 : value.top) ?? 0,\n    right: (null === value || void 0 === value ? void 0 : value.right) ?? 0,\n    bottom: (null === value || void 0 === value ? void 0 : value.bottom) ?? 0,\n    left: (null === value || void 0 === value ? void 0 : value.left) ?? 0\n  };\n}\nfunction normalizeRowsInfo(rowsInfo) {\n  rowsInfo.forEach(row => {\n    row.cells.forEach(_ref => {\n      let {\n        pdfCell: pdfCell\n      } = _ref;\n      pdfCell.padding = normalizeBoundaryValue(pdfCell.padding);\n    });\n  });\n}\nexport { normalizeRowsInfo, normalizeBoundaryValue };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/pdf_utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../../core/utils/type\";\nconst DOTS_TEXT = \"...\";\nfunction toPdfUnit(doc, value) {\n  const coefficient = 1 / doc.internal.scaleFactor;\n  return value * coefficient;\n}\nfunction getPageWidth(doc) {\n  return doc.internal.pageSize.getWidth();\n}\nfunction getPageHeight(doc) {\n  return doc.internal.pageSize.getHeight();\n}\nfunction getTextLines(doc, text, font, _ref) {\n  let {\n    wordWrapEnabled: wordWrapEnabled,\n    targetRectWidth: targetRectWidth\n  } = _ref;\n  if (wordWrapEnabled) {\n    const usedFont = doc.getFont(null === font || void 0 === font ? void 0 : font.name, null === font || void 0 === font ? void 0 : font.style);\n    return doc.splitTextToSize(text, targetRectWidth, {\n      fontSize: (null === font || void 0 === font ? void 0 : font.size) || doc.getFontSize(),\n      fontName: usedFont.fontName,\n      fontStyle: usedFont.fontStyle\n    });\n  }\n  let textWithoutLineBreak = text.split(\"\\n\").filter(ch => \"\" !== ch).join(\" \");\n  if (getTextDimensions(doc, textWithoutLineBreak, font).w <= targetRectWidth) {\n    return [textWithoutLineBreak];\n  }\n  let textWidth = getTextDimensions(doc, textWithoutLineBreak + \"...\", font).w;\n  while (textWithoutLineBreak.length > 0 && textWidth > targetRectWidth) {\n    let symbolsCountToRemove = 0;\n    if (textWidth >= 2 * targetRectWidth) {\n      symbolsCountToRemove = textWithoutLineBreak.length / 2;\n    }\n    if (symbolsCountToRemove < 1) {\n      symbolsCountToRemove = 1;\n    }\n    textWithoutLineBreak = textWithoutLineBreak.substring(0, textWithoutLineBreak.length - symbolsCountToRemove);\n    textWidth = getTextDimensions(doc, textWithoutLineBreak + \"...\", font).w;\n  }\n  return [textWithoutLineBreak + \"...\"];\n}\nfunction calculateTargetRectWidth(columnWidth, padding) {\n  const width = columnWidth - (padding.left + padding.right);\n  return width >= 0 ? width : 0;\n}\nfunction getTextDimensions(doc, text, font) {\n  return doc.getTextDimensions(text, {\n    font: doc.getFont(null === font || void 0 === font ? void 0 : font.name, null === font || void 0 === font ? void 0 : font.style),\n    fontSize: (null === font || void 0 === font ? void 0 : font.size) || doc.getFontSize()\n  });\n}\nfunction calculateTextHeight(doc, text, font, _ref2) {\n  let {\n    wordWrapEnabled: wordWrapEnabled,\n    targetRectWidth: targetRectWidth\n  } = _ref2;\n  const heightOfOneLine = getTextDimensions(doc, text, font).h;\n  const linesCount = getTextLines(doc, text, font, {\n    wordWrapEnabled: wordWrapEnabled,\n    targetRectWidth: targetRectWidth\n  }).length;\n  return heightOfOneLine * linesCount * doc.getLineHeightFactor();\n}\nfunction calculateRowHeight(doc, cells, columnWidths) {\n  if (cells.length !== columnWidths.length) {\n    throw \"the cells count must be equal to the count of the columns\";\n  }\n  let rowHeight = 0;\n  for (let cellIndex = 0; cellIndex < cells.length; cellIndex++) {\n    if (isDefined(cells[cellIndex].rowSpan)) {\n      continue;\n    }\n    const cellText = cells[cellIndex].pdfCell.text;\n    const cellPadding = cells[cellIndex].pdfCell.padding;\n    const font = cells[cellIndex].pdfCell.font;\n    const wordWrapEnabled = cells[cellIndex].pdfCell.wordWrapEnabled;\n    const columnWidth = columnWidths[cellIndex];\n    const targetRectWidth = calculateTargetRectWidth(columnWidth, cellPadding);\n    if (isDefined(cellText)) {\n      const textHeight = \"\" !== cellText ? calculateTextHeight(doc, cellText, font, {\n        wordWrapEnabled: wordWrapEnabled,\n        targetRectWidth: targetRectWidth\n      }) : 0;\n      const cellHeight = textHeight + cellPadding.top + cellPadding.bottom;\n      if (rowHeight < cellHeight) {\n        rowHeight = cellHeight;\n      }\n    }\n  }\n  return rowHeight;\n}\nfunction applyWordWrap(doc, rowsInfo) {\n  rowsInfo.forEach(row => {\n    row.cells.forEach(_ref3 => {\n      let {\n        pdfCell: pdfCell\n      } = _ref3;\n      if (isDefined(pdfCell.text)) {\n        const lines = getTextLines(doc, pdfCell.text, pdfCell.font, {\n          wordWrapEnabled: pdfCell.wordWrapEnabled,\n          targetRectWidth: calculateTargetRectWidth(pdfCell._rect.w, pdfCell.padding)\n        });\n        pdfCell.text = lines.join(\"\\n\");\n      }\n    });\n  });\n}\nfunction applyRtl(doc, rectsByPages, options) {\n  rectsByPages.forEach(pageRects => {\n    pageRects.forEach(pdfCell => {\n      const mirroredX = getPageWidth(doc) - (pdfCell._rect.x + pdfCell._rect.w);\n      const marginDiff = options.margin.left - options.margin.right;\n      pdfCell._rect.x = mirroredX + marginDiff;\n    });\n  });\n}\nexport { calculateRowHeight, calculateTextHeight, calculateTargetRectWidth, getTextDimensions, getTextLines, getPageWidth, getPageHeight, applyWordWrap, toPdfUnit, applyRtl };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/row_utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined, isNumeric } from \"../../../core/utils/type\";\nimport { calculateRowHeight, getPageWidth, toPdfUnit } from \"./pdf_utils\";\nconst getSum = (a, b) => a + b;\nfunction calculateColumnWidths(doc, dataProvider, topLeftX, margin, customerColumnWidths) {\n  const resultWidths = dataProvider.getColumnsWidths().map(width => toPdfUnit(doc, width ?? 150));\n  const totalAutoColumnsWidth = resultWidths.filter((width, index) => !isDefined(customerColumnWidths[index])).reduce(getSum, 0);\n  const totalCustomerColumnsWidth = customerColumnWidths.filter(width => isNumeric(width)).reduce(getSum, 0);\n  const availablePageWidth = getAvailablePageAreaWidth(doc, topLeftX, margin);\n  const ratio = totalCustomerColumnsWidth < availablePageWidth ? (availablePageWidth - totalCustomerColumnsWidth) / totalAutoColumnsWidth : 1;\n  return resultWidths.map((width, index) => customerColumnWidths[index] ?? width * ratio);\n}\nfunction getAvailablePageAreaWidth(doc, topLeftX, margin) {\n  return getPageWidth(doc) - topLeftX - margin.left - margin.right;\n}\nfunction initializeCellsWidth(doc, dataProvider, rows, options) {\n  const columnWidths = calculateColumnWidths(doc, dataProvider, options.topLeft.x, options.margin, options.columnWidths);\n  rows.forEach(row => {\n    row.cells.forEach((_ref, index) => {\n      let {\n        gridCell: gridCell,\n        pdfCell: pdfCell\n      } = _ref;\n      pdfCell._rect.w = columnWidths[index];\n    });\n  });\n}\nfunction calculateHeights(doc, rows, options) {\n  rows.forEach(row => {\n    const pdfCells = row.cells.map(c => c.pdfCell);\n    let customerHeight;\n    if (options.onRowExporting) {\n      const args = {\n        rowCells: pdfCells\n      };\n      options.onRowExporting(args);\n      if (isDefined(args.rowHeight)) {\n        customerHeight = args.rowHeight;\n      }\n    }\n    row.height = isDefined(customerHeight) ? customerHeight : calculateRowHeight(doc, row.cells, pdfCells.map(c => c._rect.w));\n    pdfCells.forEach(cell => {\n      cell._rect.h = row.height;\n    });\n  });\n}\nfunction applyColSpans(rows) {\n  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    const row = rows[rowIndex];\n    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\n      const cell = row.cells[cellIndex];\n      if (isDefined(cell.colSpan) && !isDefined(cell.pdfCell.isMerged)) {\n        for (let spanIndex = 1; spanIndex <= cell.colSpan; spanIndex++) {\n          const mergedCell = rows[rowIndex].cells[cellIndex + spanIndex];\n          cell.pdfCell._rect.w += mergedCell.pdfCell._rect.w;\n          mergedCell.pdfCell._rect.w = 0;\n          mergedCell.pdfCell.isMerged = true;\n        }\n      }\n    }\n  }\n}\nfunction applyRowSpans(rows) {\n  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    const row = rows[rowIndex];\n    for (let cellIndex = 0; cellIndex < row.cells.length; cellIndex++) {\n      const cell = row.cells[cellIndex];\n      if (isDefined(cell.rowSpan) && !isDefined(cell.pdfCell.isMerged)) {\n        for (let spanIndex = 1; spanIndex <= cell.rowSpan; spanIndex++) {\n          const mergedCell = rows[rowIndex + spanIndex].cells[cellIndex];\n          cell.pdfCell._rect.h += mergedCell.pdfCell._rect.h;\n          mergedCell.pdfCell._rect.h = 0;\n          mergedCell.pdfCell.isMerged = true;\n        }\n      }\n    }\n  }\n}\nfunction resizeFirstColumnByIndentLevel(rows, options) {\n  rows.forEach(row => {\n    row.cells[0].pdfCell._rect.w -= row.indentLevel * options.indent;\n  });\n}\nfunction applyBordersConfig(rows) {\n  for (let rowIndex = 0; rowIndex < rows.length; rowIndex++) {\n    const cells = rows[rowIndex].cells;\n    for (let columnIndex = 0; columnIndex < cells.length; columnIndex++) {\n      const pdfCell = cells[columnIndex].pdfCell;\n      const leftPdfCell = columnIndex >= 1 ? cells[columnIndex - 1].pdfCell : null;\n      const topPdfCell = rowIndex >= 1 ? rows[rowIndex - 1].cells[columnIndex].pdfCell : null;\n      if (false === pdfCell.drawLeftBorder && !isDefined(cells[columnIndex].colSpan)) {\n        if (isDefined(leftPdfCell)) {\n          leftPdfCell.drawRightBorder = false;\n        }\n      } else if (!isDefined(pdfCell.drawLeftBorder)) {\n        if (isDefined(leftPdfCell) && false === leftPdfCell.drawRightBorder) {\n          pdfCell.drawLeftBorder = false;\n        }\n      }\n      if (false === pdfCell.drawTopBorder) {\n        if (isDefined(topPdfCell)) {\n          topPdfCell.drawBottomBorder = false;\n        }\n      } else if (!isDefined(pdfCell.drawTopBorder)) {\n        if (isDefined(topPdfCell) && false === topPdfCell.drawBottomBorder) {\n          pdfCell.drawTopBorder = false;\n        }\n      }\n    }\n  }\n}\nfunction calculateCoordinates(doc, rows, options) {\n  const topLeft = null === options || void 0 === options ? void 0 : options.topLeft;\n  const margin = null === options || void 0 === options ? void 0 : options.margin;\n  let y = ((null === topLeft || void 0 === topLeft ? void 0 : topLeft.y) ?? 0) + margin.top;\n  rows.forEach(row => {\n    let x = ((null === topLeft || void 0 === topLeft ? void 0 : topLeft.x) ?? 0) + margin.left;\n    const intend = row.indentLevel * options.indent;\n    row.cells.forEach(cell => {\n      cell.pdfCell._rect.x = x + intend;\n      cell.pdfCell._rect.y = y;\n      x += cell.pdfCell._rect.w;\n    });\n    y += row.height;\n  });\n}\nfunction calculateTableSize(doc, cells, options) {\n  var _options$topLeft, _options$topLeft2;\n  let leftPos;\n  let topPos;\n  let rightPos;\n  let bottomPos;\n  cells.forEach(cell => {\n    if (!isDefined(leftPos) || leftPos > cell._rect.x) {\n      leftPos = cell._rect.x;\n    }\n    if (!isDefined(topPos) || topPos > cell._rect.y) {\n      topPos = cell._rect.y;\n    }\n    if (!isDefined(rightPos) || rightPos < cell._rect.x + cell._rect.w) {\n      rightPos = cell._rect.x + cell._rect.w;\n    }\n    if (!isDefined(bottomPos) || bottomPos < cell._rect.y + cell._rect.h) {\n      bottomPos = cell._rect.y + cell._rect.h;\n    }\n  });\n  const x = leftPos ?? (null === options || void 0 === options || null === (_options$topLeft = options.topLeft) || void 0 === _options$topLeft ? void 0 : _options$topLeft.x) ?? 0;\n  const y = topPos ?? (null === options || void 0 === options || null === (_options$topLeft2 = options.topLeft) || void 0 === _options$topLeft2 ? void 0 : _options$topLeft2.y) ?? 0;\n  const w = isDefined(rightPos) ? rightPos - x : 0;\n  const h = isDefined(bottomPos) ? bottomPos - y : 0;\n  return {\n    x: x,\n    y: y,\n    w: w,\n    h: h\n  };\n}\nexport { initializeCellsWidth, applyColSpans, applyRowSpans, resizeFirstColumnByIndentLevel, applyBordersConfig, calculateHeights, calculateCoordinates, calculateTableSize };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/height_updater.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../../core/utils/type\";\nimport { calculateTextHeight, calculateTargetRectWidth } from \"./pdf_utils\";\nfunction updateRowsAndCellsHeights(doc, rows) {\n  const rowsAdditionalHeights = calculateAdditionalRowsHeights(doc, rows);\n  rows.forEach(row => {\n    row.height += rowsAdditionalHeights[row.rowIndex];\n  });\n  rows.forEach(row => {\n    row.cells.forEach(cell => {\n      const rowsCount = (cell.rowSpan ?? 0) + 1;\n      cell.pdfCell._rect.h = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce((accumulator, rowInfo) => accumulator + rowInfo.height, 0);\n    });\n  });\n}\nfunction calculateAdditionalRowsHeights(doc, rows) {\n  const rowsAdditionalHeights = Array.from({\n    length: rows.length\n  }, () => 0);\n  const sortedRows = sortRowsByMaxRowSpanAsc(rows);\n  sortedRows.forEach(row => {\n    const cellsWithRowSpan = row.cells.filter(cell => isDefined(cell.rowSpan));\n    cellsWithRowSpan.forEach(cell => {\n      const targetRectWidth = calculateTargetRectWidth(cell.pdfCell._rect.w, cell.pdfCell.padding);\n      const textHeight = calculateTextHeight(doc, cell.pdfCell.text, cell.pdfCell.font, {\n        wordWrapEnabled: cell.pdfCell.wordWrapEnabled,\n        targetRectWidth: targetRectWidth\n      });\n      const cellHeight = textHeight + cell.pdfCell.padding.top + cell.pdfCell.padding.bottom;\n      const rowsCount = cell.rowSpan + 1;\n      const currentRowSpanRowsHeight = rows.slice(row.rowIndex, row.rowIndex + rowsCount).reduce((accumulator, rowInfo) => accumulator + rowInfo.height + rowsAdditionalHeights[rowInfo.rowIndex], 0);\n      if (cellHeight > currentRowSpanRowsHeight) {\n        const delta = (cellHeight - currentRowSpanRowsHeight) / rowsCount;\n        for (let spanIndex = row.rowIndex; spanIndex < row.rowIndex + rowsCount; spanIndex++) {\n          rowsAdditionalHeights[spanIndex] += delta;\n        }\n      }\n    });\n  });\n  return rowsAdditionalHeights;\n}\nfunction sortRowsByMaxRowSpanAsc(rows) {\n  const getMaxRowSpan = row => {\n    const spansArray = row.cells.map(cell => cell.rowSpan ?? 0);\n    return Math.max(...spansArray);\n  };\n  return [...rows].sort((row1, row2) => {\n    const row1RowSpan = getMaxRowSpan(row1);\n    const row2RowSpan = getMaxRowSpan(row2);\n    if (row1RowSpan > row2RowSpan) {\n      return 1;\n    }\n    if (row2RowSpan > row1RowSpan) {\n      return -1;\n    }\n    return 0;\n  });\n}\nexport { updateRowsAndCellsHeights };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_generator.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDate, isDefined, isNumeric } from \"../../../core/utils/type\";\nimport dateLocalization from \"../../../common/core/localization/date\";\nimport numberLocalization from \"../../../common/core/localization/number\";\nimport { toPdfUnit } from \"./pdf_utils\";\nconst defaultStyles = {\n  base: {\n    font: {\n      size: 10\n    },\n    borderWidth: .5,\n    borderColor: \"#979797\"\n  },\n  header: {\n    textColor: \"#979797\"\n  },\n  group: {},\n  data: {},\n  groupFooter: {},\n  totalFooter: {}\n};\nfunction generateRowsInfo(doc, dataProvider, dataGrid, headerBackgroundColor) {\n  const result = [];\n  const rowsCount = dataProvider.getRowsCount();\n  const wordWrapEnabled = !!dataGrid.option(\"wordWrapEnabled\");\n  const rtlEnabled = !!dataGrid.option(\"rtlEnabled\");\n  const columns = dataProvider.getColumns();\n  const styles = dataProvider.getStyles();\n  for (let rowIndex = 0; rowIndex < rowsCount; rowIndex++) {\n    const rowType = dataProvider.getCellData(rowIndex, 0, true).cellSourceData.rowType;\n    let indentLevel = \"header\" !== rowType ? dataProvider.getGroupLevel(rowIndex) : 0;\n    const previousRow = result[rowIndex - 1];\n    if (\"groupFooter\" === rowType && \"groupFooter\" === (null === previousRow || void 0 === previousRow ? void 0 : previousRow.rowType)) {\n      indentLevel = previousRow.indentLevel - 1;\n    }\n    result.push({\n      rowType: rowType,\n      indentLevel: indentLevel,\n      cells: generateRowCells({\n        doc: doc,\n        dataProvider: dataProvider,\n        rowIndex: rowIndex,\n        wordWrapEnabled: wordWrapEnabled,\n        columns: columns,\n        styles: styles,\n        rowType: rowType,\n        backgroundColor: \"header\" === rowType ? headerBackgroundColor : void 0,\n        rtlEnabled: rtlEnabled\n      }),\n      rowIndex: rowIndex\n    });\n  }\n  return result;\n}\nfunction generateRowCells(_ref) {\n  let {\n    doc: doc,\n    dataProvider: dataProvider,\n    rowIndex: rowIndex,\n    wordWrapEnabled: wordWrapEnabled,\n    columns: columns,\n    styles: styles,\n    rowType: rowType,\n    backgroundColor: backgroundColor,\n    rtlEnabled: rtlEnabled\n  } = _ref;\n  const result = [];\n  for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {\n    const cellData = dataProvider.getCellData(rowIndex, cellIndex, true);\n    const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];\n    const style = getPdfCellStyle(columns[cellIndex], rowType, cellStyle);\n    const defaultAlignment = rtlEnabled ? \"right\" : \"left\";\n    const paddingValue = toPdfUnit(doc, 5);\n    const pdfCell = {\n      text: getFormattedValue(cellData.value, cellStyle.format),\n      verticalAlign: \"middle\",\n      horizontalAlign: style.alignment ?? defaultAlignment,\n      wordWrapEnabled: wordWrapEnabled,\n      backgroundColor: backgroundColor,\n      padding: {\n        top: paddingValue,\n        right: paddingValue,\n        bottom: paddingValue,\n        left: paddingValue\n      },\n      _rect: {},\n      _internalTextOptions: {}\n    };\n    if (rtlEnabled) {\n      pdfCell._internalTextOptions.isInputVisual = false;\n      pdfCell._internalTextOptions.isOutputVisual = true;\n      pdfCell._internalTextOptions.isInputRtl = true;\n      pdfCell._internalTextOptions.isOutputRtl = false;\n    }\n    const cellInfo = {\n      gridCell: cellData.cellSourceData,\n      pdfCell: Object.assign({}, pdfCell, style)\n    };\n    if (\"header\" === rowType) {\n      const cellMerging = dataProvider.getCellMerging(rowIndex, cellIndex);\n      if (cellMerging && cellMerging.rowspan > 0) {\n        cellInfo.rowSpan = cellMerging.rowspan;\n      }\n      if (cellMerging && cellMerging.colspan > 0) {\n        cellInfo.colSpan = cellMerging.colspan;\n      }\n    } else if (\"group\" === rowType) {\n      const drawLeftBorderField = rtlEnabled ? \"drawRightBorder\" : \"drawLeftBorder\";\n      const drawRightBorderField = rtlEnabled ? \"drawLeftBorder\" : \"drawRightBorder\";\n      cellInfo.pdfCell[drawLeftBorderField] = 0 === cellIndex;\n      cellInfo.pdfCell[drawRightBorderField] = cellIndex === columns.length - 1;\n      if (cellIndex > 0) {\n        const isEmptyCellsExceptFirst = result.slice(1).reduce((accumulate, cellInfo) => accumulate && !isDefined(cellInfo.pdfCell.text), true);\n        if (!isDefined(cellInfo.pdfCell.text) && isEmptyCellsExceptFirst) {\n          result[0].pdfCell[drawRightBorderField] = true;\n          for (let i = 0; i < result.length; i++) {\n            result[i].colSpan = result.length;\n          }\n          cellInfo.colSpan = result.length;\n        }\n      }\n    }\n    result.push(cellInfo);\n  }\n  return result;\n}\nfunction getBaseTableStyle() {\n  return defaultStyles.base;\n}\nfunction getPdfCellStyle(column, rowType, cellStyle) {\n  const styles = Object.assign({}, defaultStyles.base, defaultStyles[rowType]);\n  const alignment = \"header\" === rowType ? column.alignment : cellStyle.alignment;\n  if (alignment) {\n    styles.alignment = alignment;\n  }\n  if (cellStyle.bold && \"header\" !== rowType) {\n    styles.font = Object.assign({}, styles.font, {\n      style: \"bold\"\n    });\n  }\n  return styles;\n}\nfunction getFormattedValue(value, format) {\n  if (isDefined(format)) {\n    if (isDate(value)) {\n      return dateLocalization.format(value, format);\n    }\n    if (isNumeric(value)) {\n      return numberLocalization.format(value, format);\n    }\n  }\n  return null === value || void 0 === value ? void 0 : value.toString();\n}\nexport { generateRowsInfo, getBaseTableStyle };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/draw_utils.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _objectWithoutPropertiesLoose from \"@babel/runtime/helpers/esm/objectWithoutPropertiesLoose\";\nconst _excluded = [\"_rect\", \"gridCell\"];\nimport { isDefined } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { calculateTextHeight, toPdfUnit } from \"./pdf_utils\";\nfunction capitalizeFirstLetter(string) {\n  return string.charAt(0).toUpperCase() + string.slice(1);\n}\nfunction roundToThreeDecimals(value) {\n  return Math.round(1e3 * value) / 1e3;\n}\nfunction drawCellsContent(doc, customDrawCell, cellsArray, docStyles) {\n  cellsArray.forEach(cell => {\n    const {\n        _rect: _rect,\n        gridCell: gridCell\n      } = cell,\n      pdfCell = _objectWithoutPropertiesLoose(cell, _excluded);\n    const {\n      x: x,\n      y: y,\n      w: w,\n      h: h\n    } = _rect;\n    const rect = {\n      x: x,\n      y: y,\n      w: w,\n      h: h\n    };\n    const eventArg = {\n      doc: doc,\n      rect: rect,\n      pdfCell: pdfCell,\n      gridCell: gridCell,\n      cancel: false\n    };\n    null === customDrawCell || void 0 === customDrawCell || customDrawCell(eventArg);\n    if (!eventArg.cancel) {\n      drawCellBackground(doc, cell);\n      drawCellText(doc, cell, docStyles);\n    }\n  });\n}\nfunction drawLine(doc, startX, startY, endX, endY) {\n  doc.line(roundToThreeDecimals(startX), roundToThreeDecimals(startY), roundToThreeDecimals(endX), roundToThreeDecimals(endY));\n}\nfunction drawRect(doc, x, y, width, height, style) {\n  if (isDefined(style)) {\n    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height), style);\n  } else {\n    doc.rect(roundToThreeDecimals(x), roundToThreeDecimals(y), roundToThreeDecimals(width), roundToThreeDecimals(height));\n  }\n}\nfunction getLineHeightShift(doc) {\n  return (doc.getLineHeightFactor() - 1.15) * doc.getFontSize();\n}\nfunction drawTextInRect(doc, text, rect, verticalAlign, horizontalAlign, jsPDFTextOptions) {\n  const textArray = text.split(\"\\n\");\n  const linesCount = textArray.length;\n  const heightOfOneLine = calculateTextHeight(doc, textArray[0], doc.getFont(), {\n    wordWrapEnabled: false,\n    targetRectWidth: 1e9\n  });\n  const vAlign = verticalAlign ?? \"middle\";\n  const hAlign = horizontalAlign ?? \"left\";\n  const verticalAlignCoefficientsMap = {\n    top: 0,\n    middle: .5,\n    bottom: 1\n  };\n  const y = rect.y + rect.h * verticalAlignCoefficientsMap[vAlign] - heightOfOneLine * (linesCount - 1) * verticalAlignCoefficientsMap[vAlign] + getLineHeightShift(doc);\n  const x = rect.x + rect.w * {\n    left: 0,\n    center: .5,\n    right: 1\n  }[hAlign];\n  const textOptions = extend({\n    baseline: vAlign,\n    align: hAlign\n  }, jsPDFTextOptions);\n  doc.text(textArray.join(\"\\n\"), roundToThreeDecimals(x), roundToThreeDecimals(y), textOptions);\n}\nfunction drawCellBackground(doc, cell) {\n  if (isDefined(cell.backgroundColor)) {\n    trySetColor(doc, \"fill\", cell.backgroundColor);\n    drawRect(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h, \"F\");\n  }\n}\nfunction drawCellText(doc, cell, docStyles) {\n  if (isDefined(cell.text) && \"\" !== cell.text) {\n    const {\n      textColor: textColor,\n      font: font,\n      _rect: _rect,\n      padding: padding\n    } = cell;\n    setTextStyles(doc, {\n      textColor: textColor,\n      font: font\n    }, docStyles);\n    const textRect = {\n      x: _rect.x + padding.left,\n      y: _rect.y + padding.top,\n      w: _rect.w - (padding.left + padding.right),\n      h: _rect.h - (padding.top + padding.bottom)\n    };\n    if (isDefined(cell._textLeftOffset) || isDefined(cell._textTopOffset)) {\n      textRect.x = textRect.x + (cell._textLeftOffset ?? 0);\n      textRect.y = textRect.y + (cell._textTopOffset ?? 0);\n      doc.saveGraphicsState();\n      clipOutsideRectContent(doc, cell._rect.x, cell._rect.y, cell._rect.w, cell._rect.h);\n    }\n    drawTextInRect(doc, cell.text, textRect, cell.verticalAlign, cell.horizontalAlign, cell._internalTextOptions);\n    if (isDefined(cell._textLeftOffset) || isDefined(cell._textTopOffset)) {\n      doc.restoreGraphicsState();\n    }\n  }\n}\nfunction drawCellsLines(doc, cellsArray, docStyles) {\n  cellsArray.filter(cell => !isDefined(cell.borderColor)).forEach(cell => {\n    drawBorders(doc, cell._rect, cell, docStyles);\n  });\n  cellsArray.filter(cell => isDefined(cell.borderColor)).forEach(cell => {\n    drawBorders(doc, cell._rect, cell, docStyles);\n  });\n}\nfunction drawGridLines(doc, rect, options, docStyles) {\n  drawBorders(doc, rect, options, docStyles);\n}\nfunction drawBorders(doc, rect, _ref, docStyles) {\n  let {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    drawLeftBorder = true,\n    drawRightBorder = true,\n    drawTopBorder = true,\n    drawBottomBorder = true\n  } = _ref;\n  if (!isDefined(rect)) {\n    throw \"rect is required\";\n  }\n  if (!drawLeftBorder && !drawRightBorder && !drawTopBorder && !drawBottomBorder) {\n    return;\n  } else if (drawLeftBorder && drawRightBorder && drawTopBorder && drawBottomBorder) {\n    setLinesStyles(doc, {\n      borderWidth: borderWidth,\n      borderColor: borderColor\n    }, docStyles);\n    drawRect(doc, rect.x, rect.y, rect.w, rect.h);\n  } else {\n    setLinesStyles(doc, {\n      borderWidth: borderWidth,\n      borderColor: borderColor\n    }, docStyles);\n    if (drawTopBorder) {\n      drawLine(doc, rect.x, rect.y, rect.x + rect.w, rect.y);\n    }\n    if (drawLeftBorder) {\n      drawLine(doc, rect.x, rect.y, rect.x, rect.y + rect.h);\n    }\n    if (drawRightBorder) {\n      drawLine(doc, rect.x + rect.w, rect.y, rect.x + rect.w, rect.y + rect.h);\n    }\n    if (drawBottomBorder) {\n      drawLine(doc, rect.x, rect.y + rect.h, rect.x + rect.w, rect.y + rect.h);\n    }\n  }\n}\nfunction setTextStyles(doc, _ref2, docStyles) {\n  let {\n    textColor: textColor,\n    font: font\n  } = _ref2;\n  trySetColor(doc, \"text\", isDefined(textColor) ? textColor : docStyles.textColor);\n  const currentFont = isDefined(font) ? extend({}, docStyles.font, font) : docStyles.font;\n  const docFont = doc.getFont();\n  if (currentFont.name !== docFont.fontName || currentFont.style !== docFont.fontStyle || isDefined(currentFont.weight)) {\n    doc.setFont(currentFont.name, currentFont.style, currentFont.weight);\n  }\n  if (currentFont.size !== doc.getFontSize()) {\n    doc.setFontSize(currentFont.size);\n  }\n}\nfunction setLinesStyles(doc, _ref3, docStyles) {\n  let {\n    borderWidth: borderWidth,\n    borderColor: borderColor\n  } = _ref3;\n  const currentBorderWidth = isDefined(borderWidth) ? borderWidth : docStyles.borderWidth;\n  if (currentBorderWidth !== getDocBorderWidth(doc)) {\n    setDocBorderWidth(doc, toPdfUnit(doc, currentBorderWidth));\n  }\n  trySetColor(doc, \"draw\", isDefined(borderColor) ? borderColor : docStyles.borderColor);\n}\nfunction trySetColor(doc, target, color) {\n  const getterName = `get${capitalizeFirstLetter(target)}Color`;\n  const setterName = `set${capitalizeFirstLetter(target)}Color`;\n  const {\n    ch1 = color,\n    ch2: ch2,\n    ch3: ch3,\n    ch4: ch4\n  } = color;\n  const normalizedColor = doc.__private__.decodeColorString(doc.__private__.encodeColorString({\n    ch1: ch1,\n    ch2: ch2,\n    ch3: ch3,\n    ch4: ch4,\n    precision: \"text\" === target ? 3 : 2\n  }));\n  if (normalizedColor !== doc[getterName]() || \"fill\" === target) {\n    doc[setterName].apply(doc, [ch1, ch2, ch3, ch4].filter(item => void 0 !== item));\n  }\n}\nfunction getDocumentStyles(doc) {\n  const docFont = doc.getFont();\n  return {\n    borderWidth: getDocBorderWidth(doc),\n    borderColor: doc.getDrawColor(),\n    font: {\n      name: docFont.fontName,\n      style: docFont.fontStyle,\n      size: doc.getFontSize()\n    },\n    textColor: doc.getTextColor()\n  };\n}\nfunction setDocumentStyles(doc, styles) {\n  const {\n    borderWidth: borderWidth,\n    borderColor: borderColor,\n    font: font,\n    textColor: textColor\n  } = styles;\n  const docFont = doc.getFont();\n  if (docFont.fontName !== font.name || docFont.fontStyle !== font.style) {\n    doc.setFont(font.name, font.style, void 0);\n  }\n  const docFontSize = doc.getFontSize();\n  if (docFontSize !== font.size) {\n    doc.setFontSize(font.size);\n  }\n  if (getDocBorderWidth(doc) !== borderWidth) {\n    setDocBorderWidth(doc, borderWidth);\n  }\n  if (doc.getDrawColor() !== borderColor) {\n    doc.setDrawColor(borderColor);\n  }\n  if (doc.getTextColor() !== textColor) {\n    doc.setTextColor(textColor);\n  }\n}\nfunction addNewPage(doc) {\n  doc.addPage();\n  resetDocBorderWidth(doc);\n}\nfunction getDocBorderWidth(doc) {\n  if (isDefined(doc.getLineWidth)) {\n    return doc.getLineWidth();\n  }\n  return doc.__borderWidth ?? .200025;\n}\nfunction setDocBorderWidth(doc, width) {\n  doc.setLineWidth(width);\n  if (!isDefined(doc.getLineWidth)) {\n    doc.__borderWidth = width;\n  }\n}\nfunction resetDocBorderWidth(doc) {\n  if (!isDefined(doc.getLineWidth)) {\n    doc.__borderWidth = null;\n  }\n}\nfunction clipOutsideRectContent(doc, x, y, w, h) {\n  doc.moveTo(roundToThreeDecimals(x), roundToThreeDecimals(y));\n  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y));\n  doc.lineTo(roundToThreeDecimals(x + w), roundToThreeDecimals(y + h));\n  doc.lineTo(roundToThreeDecimals(x), roundToThreeDecimals(y + h));\n  doc.clip();\n  doc.discardPath();\n}\nexport { drawCellsContent, drawCellsLines, drawGridLines, getDocumentStyles, setDocumentStyles, drawTextInRect, drawRect, drawLine, roundToThreeDecimals, addNewPage };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_spliting_utils/get_multipage_row_pages.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nconst isHeader = rect => \"header\" === (null === rect || void 0 === rect ? void 0 : rect.sourceCellInfo.gridCell.rowType);\nconst spitMultiPageRows = (rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc) => {\n  let [newPageRects, remainPageRects] = splitMultiPageRowFunc(isCurrentPageContainsOnlyHeader, rectsToPatch);\n  const newPageRectsArray = [isCurrentPageContainsOnlyHeader ? newPageRects.map(rect => _extends({}, rect, {\n    y: firstRectYAdjustment\n  })) : newPageRects];\n  while (!checkIsFitToPageFunc(false, remainPageRects[0].h)) {\n    [newPageRects, remainPageRects] = splitMultiPageRowFunc(false, remainPageRects);\n    newPageRectsArray.push(newPageRects);\n  }\n  return [newPageRectsArray, remainPageRects];\n};\nconst patchRects = (rectsToSplit, rectsToPatch, remainPageRects) => {\n  rectsToPatch.forEach((rect, rectIndex) => {\n    rect.sourceCellInfo.text = remainPageRects[rectIndex].sourceCellInfo.text;\n    rect.h = remainPageRects[rectIndex].h;\n  });\n  const untouchedRowIdx = rectsToSplit.indexOf(rectsToPatch[rectsToPatch.length - 1]) + 1;\n  if (untouchedRowIdx >= rectsToSplit.length) {\n    return;\n  }\n  const delta = rectsToSplit[untouchedRowIdx].y - (rectsToPatch[0].y + remainPageRects[0].h);\n  for (let idx = untouchedRowIdx; idx < rectsToSplit.length; idx++) {\n    rectsToSplit[idx].y = rectsToSplit[idx].y - delta;\n  }\n};\nexport const checkPageContainsOnlyHeader = (pageRects, isFirstPage) => isFirstPage && isHeader(pageRects[pageRects.length - 1]);\nexport const getMultiPageRowPages = (currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, splitMultiPageRowFunc, checkIsFitToPageFunc) => {\n  if (!splitMultiPageRowFunc) {\n    return [];\n  }\n  const currentPageLastRect = currentPageRects[currentPageRects.length - 1];\n  const nextPageFirstRect = rectsToSplit[currentPageRects.length];\n  if (!nextPageFirstRect || isHeader(nextPageFirstRect)) {\n    return [];\n  }\n  const isRectsFitsToPage = checkIsFitToPageFunc(isCurrentPageContainsOnlyHeader, nextPageFirstRect.h);\n  if (isRectsFitsToPage && !isCurrentPageContainsOnlyHeader) {\n    return [];\n  }\n  const rectsToPatch = rectsToSplit.filter(_ref => {\n    let {\n      y: y\n    } = _ref;\n    return y === nextPageFirstRect.y;\n  });\n  const firstRectYAdjustment = currentPageLastRect.y + currentPageLastRect.h;\n  const [multiPageRowPages, remainPageRects] = spitMultiPageRows(rectsToPatch, isCurrentPageContainsOnlyHeader, firstRectYAdjustment, splitMultiPageRowFunc, checkIsFitToPageFunc);\n  patchRects(rectsToSplit, rectsToPatch, remainPageRects);\n  return multiPageRowPages;\n};", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_spliting_utils/create_on_split_multipage_row.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { getTextLines, getTextDimensions, calculateTextHeight } from \"../pdf_utils\";\nfunction createMultiCellRect(rect, text, marginTop) {\n  return _extends({}, rect, {\n    sourceCellInfo: _extends({}, rect.sourceCellInfo, {\n      text: text\n    }),\n    y: marginTop\n  });\n}\nexport const createOnSplitMultiPageRow = (doc, options, headerHeight, maxBottomRight) => (isFirstPage, pageRects) => {\n  const currentPageRects = [];\n  const nextPageRects = [];\n  let maxCurrentPageHeight = 0;\n  let maxNextPageHeight = 0;\n  pageRects.forEach(rect => {\n    const {\n      w: w,\n      sourceCellInfo: sourceCellInfo\n    } = rect;\n    const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : headerHeight + options.topLeft.y;\n    const heightOfOneLine = getTextDimensions(doc, sourceCellInfo.text, sourceCellInfo.font).h;\n    const paddingHeight = sourceCellInfo.padding.top + sourceCellInfo.padding.bottom;\n    const fullPageHeight = maxBottomRight.y - additionalHeight - paddingHeight - options.margin.top;\n    const possibleLinesCount = Math.floor(fullPageHeight / (heightOfOneLine * doc.getLineHeightFactor()));\n    const allLines = getTextLines(doc, sourceCellInfo.text, sourceCellInfo.font, {\n      wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\n      targetRectWidth: w\n    });\n    if (possibleLinesCount < allLines.length) {\n      const currentPageText = allLines.slice(0, possibleLinesCount).join(\"\\n\");\n      const currentPageHeight = calculateTextHeight(doc, currentPageText, sourceCellInfo.font, {\n        wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\n        targetRectWidth: w\n      });\n      maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);\n      maxNextPageHeight = rect.h - currentPageHeight;\n      currentPageRects.push(createMultiCellRect(rect, currentPageText, options.margin.top));\n      nextPageRects.push(createMultiCellRect(rect, allLines.slice(possibleLinesCount).join(\"\\n\"), options.margin.top));\n    } else {\n      const currentPageHeight = calculateTextHeight(doc, sourceCellInfo.text, sourceCellInfo.font, {\n        wordWrapEnabled: sourceCellInfo.wordWrapEnabled,\n        targetRectWidth: w\n      });\n      maxCurrentPageHeight = Math.max(maxCurrentPageHeight, currentPageHeight + paddingHeight);\n      maxNextPageHeight = Math.max(maxNextPageHeight, currentPageHeight + paddingHeight);\n      currentPageRects.push(createMultiCellRect(rect, sourceCellInfo.text, options.margin.top));\n      nextPageRects.push(createMultiCellRect(rect, \"\", options.margin.top));\n    }\n  });\n  currentPageRects.forEach(rect => rect.h = maxCurrentPageHeight);\n  nextPageRects.forEach(rect => rect.h = maxNextPageHeight);\n  return [currentPageRects, nextPageRects];\n};", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/rows_splitting.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport { isDefined } from \"../../../core/utils/type\";\nimport { getPageWidth, getPageHeight } from \"./pdf_utils\";\nimport { roundToThreeDecimals } from \"./draw_utils\";\nimport { getMultiPageRowPages, checkPageContainsOnlyHeader } from \"./rows_spliting_utils/get_multipage_row_pages\";\nimport { createOnSplitMultiPageRow } from \"./rows_spliting_utils/create_on_split_multipage_row\";\nconst COORDINATE_EPSILON = .001;\nfunction convertToCellsArray(rows) {\n  return [].concat.apply([], rows.map(rowInfo => rowInfo.cells.filter(cell => !isDefined(cell.pdfCell.isMerged)).map(cellInfo => Object.assign({}, cellInfo.pdfCell._rect, {\n    sourceCellInfo: _extends({}, cellInfo.pdfCell, {\n      gridCell: cellInfo.gridCell\n    })\n  }))));\n}\nfunction splitByPages(doc, rowsInfo, options, onSeparateRectHorizontally, onSeparateRectVertically) {\n  if (0 === rowsInfo.length) {\n    return [[]];\n  }\n  const maxBottomRight = {\n    x: getPageWidth(doc) - options.margin.right,\n    y: getPageHeight(doc) - options.margin.bottom\n  };\n  const headerRows = rowsInfo.filter(r => \"header\" === r.rowType);\n  const headerHeight = headerRows.reduce((accumulator, row) => accumulator + row.height, 0);\n  const verticallyPages = splitRectsByPages(convertToCellsArray(rowsInfo), options.margin.top, \"y\", \"h\", (isFirstPage, currentCoordinate) => {\n    const additionalHeight = !isFirstPage && options.repeatHeaders ? headerHeight : 0;\n    return roundToThreeDecimals(currentCoordinate + additionalHeight) <= roundToThreeDecimals(maxBottomRight.y);\n  }, (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {\n    const args = {\n      sourceRect: rect,\n      topRect: {\n        x: rect.x,\n        y: rect.y,\n        w: rect.w,\n        h: currentPageMaxRectCoordinate - rect.y\n      },\n      bottomRect: {\n        x: rect.x,\n        y: currentPageMaxRectCoordinate,\n        w: rect.w,\n        h: rect.h - (currentPageMaxRectCoordinate - rect.y)\n      }\n    };\n    onSeparateRectVertically(args);\n    currentPageRects.push(args.topRect);\n    rectsToSplit.push(args.bottomRect);\n  }, createOnSplitMultiPageRow(doc, options, headerHeight, maxBottomRight));\n  if (options.repeatHeaders) {\n    for (let i = 1; i < verticallyPages.length; i++) {\n      verticallyPages[i].forEach(rect => rect.y += headerHeight);\n      const headerCells = convertToCellsArray(headerRows);\n      headerCells.forEach(cell => {\n        cell.y -= options.topLeft.y;\n      });\n      verticallyPages[i] = [...headerCells, ...verticallyPages[i]];\n    }\n  }\n  let pageIndex = 0;\n  while (pageIndex < verticallyPages.length) {\n    const horizontallyPages = splitRectsByPages(verticallyPages[pageIndex], options.margin.left, \"x\", \"w\", (pagesLength, currentCoordinate) => roundToThreeDecimals(currentCoordinate) <= roundToThreeDecimals(maxBottomRight.x), (rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit) => {\n      const args = {\n        sourceRect: rect,\n        leftRect: {\n          x: rect.x,\n          y: rect.y,\n          w: currentPageMaxRectCoordinate - rect.x,\n          h: rect.h\n        },\n        rightRect: {\n          x: currentPageMaxRectCoordinate,\n          y: rect.y,\n          w: rect.w - (currentPageMaxRectCoordinate - rect.x),\n          h: rect.h\n        }\n      };\n      onSeparateRectHorizontally(args);\n      currentPageRects.push(args.leftRect);\n      rectsToSplit.push(args.rightRect);\n    });\n    if (horizontallyPages.length > 1) {\n      verticallyPages.splice(pageIndex, 1, ...horizontallyPages);\n      pageIndex += horizontallyPages.length;\n    } else {\n      pageIndex += 1;\n    }\n  }\n  return verticallyPages.map(rects => rects.map(rect => Object.assign({}, rect.sourceCellInfo, {\n    _rect: rect\n  })));\n}\nfunction splitRectsByPages(rects, marginValue, coordinate, dimension, isFitToPage, onSeparateCallback, onSplitMultiPageRow) {\n  const pages = [];\n  const rectsToSplit = [...rects];\n  const isFitToPageForMultiPageRow = (isFirstPage, rectHeight) => isFitToPage(isFirstPage, rectHeight + marginValue);\n  while (rectsToSplit.length > 0) {\n    let currentPageMaxRectCoordinate = 0;\n    const currentPageRects = rectsToSplit.filter(rect => {\n      const currentRectCoordinate = rect[coordinate] + rect[dimension];\n      if (isFitToPage(0 === pages.length, currentRectCoordinate)) {\n        if (currentPageMaxRectCoordinate <= currentRectCoordinate) {\n          currentPageMaxRectCoordinate = currentRectCoordinate;\n        }\n        return true;\n      } else {\n        return false;\n      }\n    });\n    const isCurrentPageContainsOnlyHeader = checkPageContainsOnlyHeader(currentPageRects, 0 === pages.length);\n    const multiPageRowPages = getMultiPageRowPages(currentPageRects, rectsToSplit, isCurrentPageContainsOnlyHeader, onSplitMultiPageRow, isFitToPageForMultiPageRow);\n    const rectsToSeparate = rectsToSplit.filter(rect => {\n      const currentRectLeft = rect[coordinate];\n      const currentRectRight = rect[coordinate] + rect[dimension];\n      return currentPageMaxRectCoordinate - currentRectLeft > .001 && currentRectRight - currentPageMaxRectCoordinate > .001;\n    });\n    rectsToSeparate.forEach(rect => {\n      onSeparateCallback(rect, currentPageMaxRectCoordinate, currentPageRects, rectsToSplit);\n      const index = rectsToSplit.indexOf(rect);\n      if (-1 !== index) {\n        rectsToSplit.splice(index, 1);\n      }\n    });\n    currentPageRects.forEach(rect => {\n      const index = rectsToSplit.indexOf(rect);\n      if (-1 !== index) {\n        rectsToSplit.splice(index, 1);\n      }\n    });\n    rectsToSplit.forEach(rect => {\n      rect[coordinate] = isDefined(currentPageMaxRectCoordinate) ? rect[coordinate] - currentPageMaxRectCoordinate + marginValue : rect[coordinate];\n    });\n    const firstPageContainsHeaderAndMultiPageRow = isCurrentPageContainsOnlyHeader && multiPageRowPages.length > 0;\n    if (firstPageContainsHeaderAndMultiPageRow) {\n      const [firstPage, ...restOfPages] = multiPageRowPages;\n      pages.push([...currentPageRects, ...firstPage]);\n      pages.push(...restOfPages);\n    } else if (currentPageRects.length > 0) {\n      pages.push(currentPageRects);\n      pages.push(...multiPageRowPages);\n    } else if (multiPageRowPages.length > 0) {\n      pages.push(...multiPageRowPages);\n      pages.push(rectsToSplit);\n    } else {\n      pages.push(rectsToSplit);\n      break;\n    }\n  }\n  return pages;\n}\nexport { splitByPages };", "/**\r\n * DevExtreme (esm/exporter/jspdf/common/export.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport { normalizeRowsInfo, normalizeBoundaryValue } from \"./normalizeOptions\";\nimport { initializeCellsWidth, applyColSpans, applyRowSpans, applyBordersConfig, calculateHeights, calculateCoordinates, calculateTableSize, resizeFirstColumnByIndentLevel } from \"./row_utils\";\nimport { updateRowsAndCellsHeights } from \"./height_updater\";\nimport { generateRowsInfo, getBaseTableStyle } from \"./rows_generator\";\nimport { splitByPages } from \"./rows_splitting\";\nimport { drawCellsContent, drawCellsLines, drawGridLines, getDocumentStyles, setDocumentStyles, addNewPage } from \"./draw_utils\";\nimport { applyRtl, applyWordWrap, toPdfUnit } from \"./pdf_utils\";\nimport messageLocalization from \"../../../common/core/localization/message\";\nimport { ExportLoadPanel } from \"../../common/export_load_panel\";\nimport { hasWindow } from \"../../../core/utils/window\";\nfunction _getFullOptions(options) {\n  const {\n    jsPDFDocument: jsPDFDocument\n  } = options;\n  const fullOptions = extend({}, options);\n  if (!isDefined(fullOptions.topLeft)) {\n    fullOptions.topLeft = {\n      x: 0,\n      y: 0\n    };\n  }\n  if (!isDefined(fullOptions.indent)) {\n    fullOptions.indent = 0;\n  }\n  if (!isDefined(fullOptions.repeatHeaders)) {\n    fullOptions.repeatHeaders = true;\n  }\n  if (!isDefined(fullOptions.margin)) {\n    fullOptions.margin = toPdfUnit(jsPDFDocument, 40);\n  }\n  fullOptions.margin = normalizeBoundaryValue(fullOptions.margin);\n  if (!Array.isArray(fullOptions.columnWidths)) {\n    fullOptions.columnWidths = [];\n  }\n  if (!isDefined(fullOptions.loadPanel)) {\n    fullOptions.loadPanel = {};\n  }\n  if (!isDefined(fullOptions.loadPanel.enabled)) {\n    fullOptions.loadPanel.enabled = true;\n  }\n  if (!isDefined(fullOptions.loadPanel.text)) {\n    fullOptions.loadPanel.text = messageLocalization.format(\"dxDataGrid-exporting\");\n  }\n  return fullOptions;\n}\nfunction exportDataGrid(options) {\n  var _component$_getIntern;\n  const {\n    jsPDFDocument: jsPDFDocument,\n    component: component,\n    selectedRowsOnly: selectedRowsOnly,\n    loadPanel: loadPanel\n  } = options;\n  const internalComponent = (null === (_component$_getIntern = component._getInternalInstance) || void 0 === _component$_getIntern ? void 0 : _component$_getIntern.call(component)) || component;\n  const initialLoadPanelEnabledOption = internalComponent.option(\"loadPanel\") && internalComponent.option(\"loadPanel\").enabled;\n  if (initialLoadPanelEnabledOption) {\n    component.option(\"loadPanel.enabled\", false);\n  }\n  let exportLoadPanel;\n  if (loadPanel.enabled && hasWindow()) {\n    const rowsView = component.getView(\"rowsView\");\n    exportLoadPanel = new ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);\n    exportLoadPanel.show();\n  }\n  const dataProvider = component.getDataProvider(selectedRowsOnly);\n  return new Promise(resolve => {\n    dataProvider.ready().done(() => {\n      var _options$rowOptions;\n      const rowsInfo = generateRowsInfo(jsPDFDocument, dataProvider, component, null === (_options$rowOptions = options.rowOptions) || void 0 === _options$rowOptions || null === (_options$rowOptions = _options$rowOptions.headerStyles) || void 0 === _options$rowOptions ? void 0 : _options$rowOptions.backgroundColor);\n      if (options.customizeCell) {\n        rowsInfo.forEach(rowInfo => rowInfo.cells.forEach(cellInfo => options.customizeCell(cellInfo)));\n      }\n      normalizeRowsInfo(rowsInfo);\n      initializeCellsWidth(jsPDFDocument, dataProvider, rowsInfo, options);\n      resizeFirstColumnByIndentLevel(rowsInfo, options);\n      applyColSpans(rowsInfo);\n      calculateHeights(jsPDFDocument, rowsInfo, options);\n      applyRowSpans(rowsInfo);\n      updateRowsAndCellsHeights(jsPDFDocument, rowsInfo);\n      calculateCoordinates(jsPDFDocument, rowsInfo, options);\n      applyBordersConfig(rowsInfo);\n      applyWordWrap(jsPDFDocument, rowsInfo);\n      const docStyles = getDocumentStyles(jsPDFDocument);\n      const rtlEnabled = !!component.option(\"rtlEnabled\");\n      const rectsByPages = splitByPages(jsPDFDocument, rowsInfo, options, _ref => {\n        var _sourceRect$sourceCel;\n        let {\n          sourceRect: sourceRect,\n          leftRect: leftRect,\n          rightRect: rightRect\n        } = _ref;\n        let leftRectTextOptions = {};\n        let rightRectTextOptions = {};\n        const isTextNotEmpty = (null === (_sourceRect$sourceCel = sourceRect.sourceCellInfo.text) || void 0 === _sourceRect$sourceCel ? void 0 : _sourceRect$sourceCel.length) > 0;\n        if (isTextNotEmpty) {\n          if (rtlEnabled) {\n            const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;\n            const isTextRightAlignment = !isDefined(sourceRect.sourceCellInfo.horizontalAlign) || \"right\" === sourceRect.sourceCellInfo.horizontalAlign;\n            if (isTextWidthGreaterThanRect || !isTextRightAlignment) {\n              var _sourceRect$sourceCel2, _sourceRect$sourceCel3, _sourceRect$sourceCel4;\n              let rightRectTextOffset;\n              let leftRectTextOffset;\n              if (\"right\" === (null === (_sourceRect$sourceCel2 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel2 ? void 0 : _sourceRect$sourceCel2.horizontalAlign)) {\n                rightRectTextOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\n                leftRectTextOffset = rightRectTextOffset + leftRect.w;\n              } else if (\"center\" === (null === (_sourceRect$sourceCel3 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel3 ? void 0 : _sourceRect$sourceCel3.horizontalAlign)) {\n                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w) + sourceRect.sourceCellInfo._rect.w / 2 - leftRect.w / 2;\n                rightRectTextOffset = leftRectTextOffset - rightRect.w;\n              } else if (\"left\" === (null === (_sourceRect$sourceCel4 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel4 ? void 0 : _sourceRect$sourceCel4.horizontalAlign)) {\n                leftRectTextOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);\n                rightRectTextOffset = leftRectTextOffset - rightRect.w;\n              }\n              leftRectTextOptions = Object.assign({}, {\n                _textLeftOffset: rightRectTextOffset\n              });\n              rightRectTextOptions = Object.assign({}, {\n                _textLeftOffset: leftRectTextOffset\n              });\n            } else {\n              rightRectTextOptions = Object.assign({}, {\n                text: \"\"\n              });\n            }\n          } else {\n            const isTextWidthGreaterThanRect = jsPDFDocument.getTextWidth(sourceRect.sourceCellInfo.text) > leftRect.w;\n            const isTextLeftAlignment = !isDefined(sourceRect.sourceCellInfo.horizontalAlign) || \"left\" === sourceRect.sourceCellInfo.horizontalAlign;\n            if (isTextWidthGreaterThanRect || !isTextLeftAlignment) {\n              var _sourceRect$sourceCel5, _sourceRect$sourceCel6, _sourceRect$sourceCel7;\n              let leftTextLeftOffset;\n              let rightTextLeftOffset;\n              if (\"left\" === (null === (_sourceRect$sourceCel5 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel5 ? void 0 : _sourceRect$sourceCel5.horizontalAlign)) {\n                leftTextLeftOffset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\n                rightTextLeftOffset = leftTextLeftOffset - leftRect.w;\n              } else if (\"center\" === (null === (_sourceRect$sourceCel6 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel6 ? void 0 : _sourceRect$sourceCel6.horizontalAlign)) {\n                const offset = sourceRect.sourceCellInfo._textLeftOffset ?? 0;\n                leftTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (leftRect.x + leftRect.w / 2);\n                rightTextLeftOffset = offset + (sourceRect.x + sourceRect.w / 2) - (rightRect.x + rightRect.w / 2);\n              } else if (\"right\" === (null === (_sourceRect$sourceCel7 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel7 ? void 0 : _sourceRect$sourceCel7.horizontalAlign)) {\n                leftTextLeftOffset = sourceRect.x + sourceRect.w - (leftRect.x + leftRect.w);\n                rightTextLeftOffset = sourceRect.x + sourceRect.w - (rightRect.x + rightRect.w);\n              }\n              leftRectTextOptions = Object.assign({}, {\n                _textLeftOffset: leftTextLeftOffset\n              });\n              rightRectTextOptions = Object.assign({}, {\n                _textLeftOffset: rightTextLeftOffset\n              });\n            } else {\n              rightRectTextOptions = Object.assign({}, {\n                text: \"\"\n              });\n            }\n          }\n        }\n        leftRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\n          debugSourceCellInfo: sourceRect.sourceCellInfo\n        }, leftRectTextOptions);\n        rightRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\n          debugSourceCellInfo: sourceRect.sourceCellInfo\n        }, rightRectTextOptions);\n      }, _ref2 => {\n        var _sourceRect$sourceCel8;\n        let {\n          sourceRect: sourceRect,\n          topRect: topRect,\n          bottomRect: bottomRect\n        } = _ref2;\n        let topRectTextOptions = {};\n        let bottomRectTextOptions = {};\n        const isTextNotEmpty = (null === (_sourceRect$sourceCel8 = sourceRect.sourceCellInfo.text) || void 0 === _sourceRect$sourceCel8 ? void 0 : _sourceRect$sourceCel8.length) > 0;\n        if (isTextNotEmpty) {\n          var _sourceRect$sourceCel9;\n          const isTextHeightGreaterThanRect = jsPDFDocument.getTextDimensions(sourceRect.sourceCellInfo.text).h > topRect.h;\n          const isTextTopAlignment = \"top\" === (null === (_sourceRect$sourceCel9 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel9 ? void 0 : _sourceRect$sourceCel9.verticalAlign);\n          if (isTextHeightGreaterThanRect || !isTextTopAlignment) {\n            var _sourceRect$sourceCel10, _sourceRect$sourceCel11, _sourceRect$sourceCel12;\n            let topTextTopOffset;\n            let bottomTextTopOffset;\n            if (\"top\" === (null === (_sourceRect$sourceCel10 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel10 ? void 0 : _sourceRect$sourceCel10.verticalAlign)) {\n              topTextTopOffset = sourceRect.sourceCellInfo._textTopOffset ?? 0;\n              bottomTextTopOffset = topTextTopOffset - topRect.h;\n            } else if (\"middle\" === (null === (_sourceRect$sourceCel11 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel11 ? void 0 : _sourceRect$sourceCel11.verticalAlign)) {\n              const offset = sourceRect.sourceCellInfo._textTopOffset ?? 0;\n              topTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (topRect.y + topRect.h / 2);\n              bottomTextTopOffset = offset + (sourceRect.y + sourceRect.h / 2) - (bottomRect.y + bottomRect.h / 2);\n            } else if (\"bottom\" === (null === (_sourceRect$sourceCel12 = sourceRect.sourceCellInfo) || void 0 === _sourceRect$sourceCel12 ? void 0 : _sourceRect$sourceCel12.verticalAlign)) {\n              topTextTopOffset = sourceRect.y + sourceRect.h - (topRect.y + topRect.h);\n              bottomTextTopOffset = sourceRect.y + sourceRect.h - (bottomRect.y + bottomRect.h);\n            }\n            topRectTextOptions = Object.assign({}, {\n              _textTopOffset: topTextTopOffset\n            });\n            bottomRectTextOptions = Object.assign({}, {\n              _textTopOffset: bottomTextTopOffset\n            });\n          } else {\n            bottomRectTextOptions = Object.assign({}, {\n              text: \"\"\n            });\n          }\n        }\n        topRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\n          debugSourceCellInfo: sourceRect.sourceCellInfo\n        }, topRectTextOptions);\n        bottomRect.sourceCellInfo = Object.assign({}, sourceRect.sourceCellInfo, {\n          debugSourceCellInfo: sourceRect.sourceCellInfo\n        }, bottomRectTextOptions);\n      });\n      if (rtlEnabled) {\n        applyRtl(jsPDFDocument, rectsByPages, options);\n      }\n      rectsByPages.forEach((pdfCellsInfo, index) => {\n        if (index > 0) {\n          addNewPage(jsPDFDocument);\n        }\n        drawCellsContent(jsPDFDocument, options.customDrawCell, pdfCellsInfo, docStyles);\n        drawCellsLines(jsPDFDocument, pdfCellsInfo, docStyles);\n        const isEmptyPdfCellsInfoSpecified = isDefined(pdfCellsInfo) && 0 === pdfCellsInfo.length;\n        if (isEmptyPdfCellsInfoSpecified) {\n          const tableRect = calculateTableSize(jsPDFDocument, pdfCellsInfo, options);\n          const baseStyle = getBaseTableStyle();\n          drawGridLines(jsPDFDocument, tableRect, baseStyle, docStyles);\n        }\n      });\n      setDocumentStyles(jsPDFDocument, docStyles);\n      resolve();\n    }).always(() => {\n      if (initialLoadPanelEnabledOption) {\n        component.option(\"loadPanel.enabled\", initialLoadPanelEnabledOption);\n      }\n      if (loadPanel.enabled && hasWindow()) {\n        exportLoadPanel.dispose();\n      }\n    });\n  });\n}\nexport const Export = {\n  getFullOptions: _getFullOptions,\n  export: exportDataGrid\n};", "/**\r\n * DevExtreme (esm/exporter/jspdf/export_data_grid.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined, isObject } from \"../../core/utils/type\";\nimport errors from \"../../core/errors\";\nimport { Export } from \"./common/export\";\nconst HOW_TO_MIGRATE_ARTICLE = \"https://supportcenter.devexpress.com/ticket/details/t1077554\";\nfunction _getFullOptions(options) {\n  if (!(isDefined(options) && isObject(options))) {\n    throw Error('The \"exportDataGrid\" method requires a configuration object.');\n  }\n  if (!(isDefined(options.component) && isObject(options.component) && \"dxDataGrid\" === options.component.NAME)) {\n    throw Error('The \"component\" field must contain a DataGrid instance.');\n  }\n  if (!(isDefined(options.jsPDFDocument) && isObject(options.jsPDFDocument))) {\n    throw Error('The \"jsPDFDocument\" field must contain a jsPDF instance.');\n  }\n  if (isDefined(options.autoTableOptions)) {\n    errors.log(\"W0001\", \"Export\", \"autoTableOptions\", \"22.1\", `You can migrate from exporting to PDF with the AutoTable plugin to a new export system. See the following topic for more information: ${HOW_TO_MIGRATE_ARTICLE}`);\n  }\n  return Export.getFullOptions(options);\n}\nfunction exportDataGrid(options) {\n  return Export.export(_getFullOptions(options));\n}\nexport { exportDataGrid };", "/**\r\n * DevExtreme (esm/exporter/jspdf/autotable/export.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDate, isDefined, isObject, isFunction, isNumeric } from \"../../../core/utils/type\";\nimport { extend } from \"../../../core/utils/extend\";\nimport dateLocalization from \"../../../common/core/localization/date\";\nimport numberLocalization from \"../../../common/core/localization/number\";\nimport messageLocalization from \"../../../common/core/localization/message\";\nimport { ExportLoadPanel } from \"../../common/export_load_panel\";\nimport { hasWindow } from \"../../../core/utils/window\";\nexport const Export = {\n  getFullOptions: function (options) {\n    const fullOptions = extend({}, options);\n    if (!(isDefined(fullOptions.jsPDFDocument) && isObject(fullOptions.jsPDFDocument))) {\n      throw Error('The \"jsPDFDocument\" field must contain a jsPDF instance.');\n    }\n    if (!(isDefined(fullOptions.jsPDFDocument.autoTable) && isFunction(fullOptions.jsPDFDocument.autoTable))) {\n      throw Error('The \"exportDataGrid\" method requires a autoTable plugin for jsPDF object.');\n    }\n    if (!isDefined(fullOptions.keepColumnWidths)) {\n      fullOptions.keepColumnWidths = true;\n    }\n    if (!isDefined(fullOptions.autoTableOptions)) {\n      fullOptions.autoTableOptions = this._getDefaultAutoTableOptions();\n    } else {\n      if (!isObject(fullOptions.autoTableOptions)) {\n        throw Error('The \"autoTableOptions\" option must be of object type.');\n      }\n      fullOptions.autoTableOptions = extend(true, {}, this._getDefaultAutoTableOptions(), fullOptions.autoTableOptions);\n    }\n    if (!isDefined(fullOptions.loadPanel)) {\n      fullOptions.loadPanel = {};\n    }\n    if (!isDefined(fullOptions.loadPanel.enabled)) {\n      fullOptions.loadPanel.enabled = true;\n    }\n    if (!isDefined(fullOptions.loadPanel.text)) {\n      fullOptions.loadPanel.text = messageLocalization.format(\"dxDataGrid-exporting\");\n    }\n    return fullOptions;\n  },\n  _getDefaultAutoTableOptions: function () {\n    return {\n      theme: \"plain\",\n      tableLineColor: 149,\n      tableLineWidth: .1,\n      styles: {\n        textColor: 51,\n        lineColor: 149,\n        lineWidth: 0\n      },\n      columnStyles: {},\n      headStyles: {\n        fontStyle: \"normal\",\n        textColor: 149,\n        lineWidth: .1\n      },\n      bodyStyles: {\n        lineWidth: .1\n      },\n      head: [],\n      body: []\n    };\n  },\n  export: function (options) {\n    var _component$_getIntern;\n    const {\n      jsPDFDocument: jsPDFDocument,\n      autoTableOptions: autoTableOptions,\n      component: component,\n      customizeCell: customizeCell,\n      keepColumnWidths: keepColumnWidths,\n      selectedRowsOnly: selectedRowsOnly,\n      loadPanel: loadPanel\n    } = options;\n    const internalComponent = (null === (_component$_getIntern = component._getInternalInstance) || void 0 === _component$_getIntern ? void 0 : _component$_getIntern.call(component)) || component;\n    const initialLoadPanelEnabledOption = internalComponent.option(\"loadPanel\") && internalComponent.option(\"loadPanel\").enabled;\n    if (initialLoadPanelEnabledOption) {\n      component.option(\"loadPanel.enabled\", false);\n    }\n    let exportLoadPanel;\n    if (loadPanel.enabled && hasWindow()) {\n      const rowsView = component.getView(\"rowsView\");\n      exportLoadPanel = new ExportLoadPanel(component, rowsView.element(), rowsView.element().parent(), loadPanel);\n      exportLoadPanel.show();\n    }\n    const dataProvider = component.getDataProvider(selectedRowsOnly);\n    const wrapText = !!component.option(\"wordWrapEnabled\");\n    return new Promise(resolve => {\n      dataProvider.ready().done(() => {\n        const columns = dataProvider.getColumns();\n        const styles = dataProvider.getStyles();\n        const dataRowsCount = dataProvider.getRowsCount();\n        const headerRowCount = dataProvider.getHeaderRowCount();\n        const mergedCells = [];\n        if (keepColumnWidths) {\n          const pdfColumnWidths = this._tryGetPdfColumnWidths(autoTableOptions.tableWidth, dataProvider.getColumnsWidths());\n          if (isDefined(pdfColumnWidths) && isDefined(autoTableOptions.columnStyles)) {\n            this._setColumnWidths(autoTableOptions.columnStyles, pdfColumnWidths);\n          }\n        }\n        for (let rowIndex = 0; rowIndex < dataRowsCount; rowIndex++) {\n          const row = [];\n          for (let cellIndex = 0; cellIndex < columns.length; cellIndex++) {\n            const {\n              value: value,\n              cellSourceData: gridCell\n            } = dataProvider.getCellData(rowIndex, cellIndex, true);\n            const cellStyle = styles[dataProvider.getStyleId(rowIndex, cellIndex)];\n            const pdfCell = {\n              content: this._getFormattedValue(value, cellStyle.format),\n              styles: this._getPDFCellStyles(gridCell.rowType, columns[cellIndex].alignment, cellStyle, wrapText)\n            };\n            if (\"header\" === gridCell.rowType) {\n              const mergedRange = this._tryGetMergeRange(rowIndex, cellIndex, mergedCells, dataProvider);\n              if (mergedRange && mergedRange.rowSpan > 0) {\n                pdfCell.rowSpan = mergedRange.rowSpan + 1;\n              }\n              if (mergedRange && mergedRange.colSpan > 0) {\n                pdfCell.colSpan = mergedRange.colSpan + 1;\n              }\n              const isMergedCell = mergedCells[rowIndex] && mergedCells[rowIndex][cellIndex];\n              if (!isMergedCell || pdfCell.rowSpan > 1 || pdfCell.colSpan > 1) {\n                if (isFunction(customizeCell)) {\n                  customizeCell({\n                    gridCell: gridCell,\n                    pdfCell: pdfCell\n                  });\n                }\n                row.push(pdfCell);\n              }\n            } else if (\"group\" === gridCell.rowType && !isDefined(pdfCell.content) && 1 === row.length) {\n              row[0].colSpan = row[0].colSpan ?? 1;\n              row[0].colSpan++;\n            } else {\n              pdfCell.content = pdfCell.content ?? \"\";\n              if (isFunction(customizeCell)) {\n                customizeCell({\n                  gridCell: gridCell,\n                  pdfCell: pdfCell\n                });\n              }\n              row.push(pdfCell);\n            }\n          }\n          if (rowIndex < headerRowCount) {\n            autoTableOptions.head.push(row);\n          } else {\n            autoTableOptions.body.push(row);\n          }\n        }\n        jsPDFDocument.autoTable(autoTableOptions);\n        resolve();\n      }).always(() => {\n        if (initialLoadPanelEnabledOption) {\n          component.option(\"loadPanel.enabled\", initialLoadPanelEnabledOption);\n        }\n        if (loadPanel.enabled && hasWindow()) {\n          exportLoadPanel.dispose();\n        }\n      });\n    });\n  },\n  _getFormattedValue: function (value, format) {\n    if (isDefined(format)) {\n      if (isDate(value)) {\n        return dateLocalization.format(value, format);\n      }\n      if (isNumeric(value)) {\n        return numberLocalization.format(value, format);\n      }\n    }\n    return value;\n  },\n  _getPDFCellStyles: function (rowType, columnAlignment, cellStyle, wrapText) {\n    const {\n      alignment: cellAlignment,\n      bold: bold\n    } = cellStyle;\n    const align = \"header\" === rowType ? columnAlignment : cellAlignment;\n    const pdfCellStyle = {};\n    if (align) {\n      pdfCellStyle.halign = align;\n    }\n    if (bold && \"header\" !== rowType) {\n      pdfCellStyle.fontStyle = \"bold\";\n    }\n    if (wrapText) {\n      pdfCellStyle.cellWidth = \"wrap\";\n    }\n    return pdfCellStyle;\n  },\n  _tryGetMergeRange: function (rowIndex, cellIndex, mergedCells, dataProvider) {\n    if (!mergedCells[rowIndex] || !mergedCells[rowIndex][cellIndex]) {\n      const {\n        colspan: colspan,\n        rowspan: rowspan\n      } = dataProvider.getCellMerging(rowIndex, cellIndex);\n      if (colspan || rowspan) {\n        for (let i = rowIndex; i <= rowIndex + rowspan || 0; i++) {\n          for (let j = cellIndex; j <= cellIndex + colspan || 0; j++) {\n            if (!mergedCells[i]) {\n              mergedCells[i] = [];\n            }\n            mergedCells[i][j] = true;\n          }\n        }\n        return {\n          rowSpan: rowspan,\n          colSpan: colspan\n        };\n      }\n    }\n  },\n  _tryGetPdfColumnWidths(autoTableWidth, columnWidths) {\n    if (isNumeric(autoTableWidth) && isDefined(columnWidths)) {\n      const tableWidth = columnWidths.reduce((a, b) => a + b, 0);\n      return columnWidths.map(columnWidth => autoTableWidth * columnWidth / tableWidth);\n    }\n  },\n  _setColumnWidths: function (autoTableColumnStyles, pdfColumnWidths) {\n    pdfColumnWidths.forEach((width, index) => {\n      autoTableColumnStyles[index] = autoTableColumnStyles[index] || {};\n      autoTableColumnStyles[index].cellWidth = width;\n    });\n  }\n};", "/**\r\n * DevExtreme (esm/exporter/jspdf/autotable/export_data_grid.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nimport { isDefined, isObject } from \"../../../core/utils/type\";\nimport { Export } from \"./export\";\nfunction _getFullOptions(options) {\n  if (!(isDefined(options) && isObject(options))) {\n    throw Error('The \"exportDataGrid\" method requires a configuration object.');\n  }\n  if (!(isDefined(options.component) && isObject(options.component) && \"dxDataGrid\" === options.component.NAME)) {\n    throw Error('The \"component\" field must contain a DataGrid instance.');\n  }\n  if (!isDefined(options.selectedRowsOnly)) {\n    options.selectedRowsOnly = false;\n  }\n  return Export.getFullOptions(options);\n}\nfunction exportDataGrid(options) {\n  return Export.export(_getFullOptions(options));\n}\nexport { exportDataGrid };", "/**\r\n * DevExtreme (esm/exporter/jspdf/export_gantt.js)\r\n * Version: 24.2.7\r\n * Build date: Mon Apr 28 2025\r\n *\r\n * Copyright (c) 2012 - 2025 Developer Express Inc. ALL RIGHTS RESERVED\r\n * Read about DevExtreme licensing here: https://js.devexpress.com/Licensing/\r\n */\nfunction exportGantt(options) {\n  const component = options.component;\n  return null === component || void 0 === component ? void 0 : component.exportToPdf(options);\n}\nexport { exportGantt };"],
  "mappings": "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",
  "names": ["cellInfo", "_getFullOptions", "exportDataGrid", "Export", "_getFullOptions", "Export", "exportDataGrid"]
}
